{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport 'abort-controller/polyfill';\nimport { UnavailabilityError } from 'expo-modules-core';\nimport ServerRegistrationModule from \"./ServerRegistrationModule\";\nimport { addPushTokenListener } from \"./TokenEmitter\";\nimport getDevicePushTokenAsync from \"./getDevicePushTokenAsync\";\nimport { updateDevicePushTokenAsync as updateDevicePushTokenAsyncWithSignal } from \"./utils/updateDevicePushTokenAsync\";\nvar lastAbortController = null;\n\nfunction updatePushTokenAsync(_x) {\n  return _updatePushTokenAsync.apply(this, arguments);\n}\n\nfunction _updatePushTokenAsync() {\n  _updatePushTokenAsync = _asyncToGenerator(function* (token) {\n    var _lastAbortController;\n\n    (_lastAbortController = lastAbortController) == null ? void 0 : _lastAbortController.abort();\n    lastAbortController = new AbortController();\n    return yield updateDevicePushTokenAsyncWithSignal(lastAbortController.signal, token);\n  });\n  return _updatePushTokenAsync.apply(this, arguments);\n}\n\nexport function setAutoServerRegistrationEnabledAsync(_x2) {\n  return _setAutoServerRegistrationEnabledAsync.apply(this, arguments);\n}\n\nfunction _setAutoServerRegistrationEnabledAsync() {\n  _setAutoServerRegistrationEnabledAsync = _asyncToGenerator(function* (enabled) {\n    var _lastAbortController2;\n\n    (_lastAbortController2 = lastAbortController) == null ? void 0 : _lastAbortController2.abort();\n\n    if (!ServerRegistrationModule.setRegistrationInfoAsync) {\n      throw new UnavailabilityError('ServerRegistrationModule', 'setRegistrationInfoAsync');\n    }\n\n    yield ServerRegistrationModule.setRegistrationInfoAsync(enabled ? JSON.stringify({\n      isEnabled: enabled\n    }) : null);\n  });\n  return _setAutoServerRegistrationEnabledAsync.apply(this, arguments);\n}\n\nexport function __handlePersistedRegistrationInfoAsync(_x3) {\n  return _handlePersistedRegistrationInfoAsync.apply(this, arguments);\n}\n\nfunction _handlePersistedRegistrationInfoAsync() {\n  _handlePersistedRegistrationInfoAsync = _asyncToGenerator(function* (registrationInfo) {\n    var _registration;\n\n    if (!registrationInfo) {\n      return;\n    }\n\n    var registration = null;\n\n    try {\n      registration = JSON.parse(registrationInfo);\n    } catch (e) {\n      console.warn('[expo-notifications] Error encountered while fetching registration information for auto token updates.', e);\n    }\n\n    if (!((_registration = registration) != null && _registration.isEnabled)) {\n      return;\n    }\n\n    try {\n      var latestDevicePushToken = yield getDevicePushTokenAsync();\n      yield updatePushTokenAsync(latestDevicePushToken);\n    } catch (e) {\n      console.warn('[expo-notifications] Error encountered while updating server registration with latest device push token.', e);\n    }\n  });\n  return _handlePersistedRegistrationInfoAsync.apply(this, arguments);\n}\n\nif (ServerRegistrationModule.getRegistrationInfoAsync) {\n  addPushTokenListener(function () {\n    var _ref = _asyncToGenerator(function* (token) {\n      try {\n        var registrationInfo = yield ServerRegistrationModule.getRegistrationInfoAsync();\n\n        if (!registrationInfo) {\n          return;\n        }\n\n        var registration = JSON.parse(registrationInfo);\n\n        if (registration != null && registration.isEnabled) {\n          yield updatePushTokenAsync(token);\n        }\n      } catch (e) {\n        console.warn('[expo-notifications] Error encountered while updating server registration with latest device push token.', e);\n      }\n    });\n\n    return function (_x4) {\n      return _ref.apply(this, arguments);\n    };\n  }());\n  ServerRegistrationModule.getRegistrationInfoAsync().then(__handlePersistedRegistrationInfoAsync);\n} else {\n  console.warn(\"[expo-notifications] Error encountered while fetching auto-registration state, new tokens will not be automatically registered on server.\", new UnavailabilityError('ServerRegistrationModule', 'getRegistrationInfoAsync'));\n}","map":{"version":3,"sources":["../src/DevicePushTokenAutoRegistration.fx.ts"],"names":[],"mappings":";AAAA,OAAO,2BAAP;AACA,SAAS,mBAAT,QAAoC,mBAApC;AAEA,OAAO,wBAAP;AACA,SAAS,oBAAT;AAEA,OAAO,uBAAP;AACA,SAAS,0BAA0B,IAAI,oCAAvC;AAEA,IAAI,mBAAmB,GAA2B,IAAlD;;SACe,oB;;;;;4CAAf,WAAoC,KAApC,EAA0D;IAAA;;IAExD,wBAAA,mBAAmB,SAAnB,iCAAqB,KAArB;IACA,mBAAmB,GAAG,IAAI,eAAJ,EAAtB;IACA,aAAa,oCAAoC,CAAC,mBAAmB,CAAC,MAArB,EAA6B,KAA7B,CAAjD;EACD,C;;;;AAcD,gBAAsB,qCAAtB;EAAA;AAAA;;;6DAAO,WAAqD,OAArD,EAAqE;IAAA;;IAG1E,yBAAA,mBAAmB,SAAnB,kCAAqB,KAArB;;IAEA,IAAI,CAAC,wBAAwB,CAAC,wBAA9B,EAAwD;MACtD,MAAM,IAAI,mBAAJ,CAAwB,0BAAxB,EAAoD,0BAApD,CAAN;IACD;;IAED,MAAM,wBAAwB,CAAC,wBAAzB,CACJ,OAAO,GAAG,IAAI,CAAC,SAAL,CAAe;MAAE,SAAS,EAAE;IAAb,CAAf,CAAH,GAA4C,IAD/C,CAAN;EAGD,C;;;;AAKD,gBAAsB,sCAAtB;EAAA;AAAA;;;4DAAO,WACL,gBADK,EACsC;IAAA;;IAE3C,IAAI,CAAC,gBAAL,EAAuB;MAErB;IACD;;IAED,IAAI,YAAY,GAAuC,IAAvD;;IACA,IAAI;MACF,YAAY,GAAG,IAAI,CAAC,KAAL,CAAW,gBAAX,CAAf;IACD,CAFD,CAEE,OAAO,CAAP,EAAU;MACV,OAAO,CAAC,IAAR,CACE,wGADF,EAEE,CAFF;IAID;;IAED,IAAI,mBAAC,YAAD,aAAC,cAAc,SAAf,CAAJ,EAA8B;MAE5B;IACD;;IAED,IAAI;MAGF,IAAM,qBAAqB,SAAS,uBAAuB,EAA3D;MACA,MAAM,oBAAoB,CAAC,qBAAD,CAA1B;IACD,CALD,CAKE,OAAO,CAAP,EAAU;MACV,OAAO,CAAC,IAAR,CACE,0GADF,EAEE,CAFF;IAID;EACF,C;;;;AAED,IAAI,wBAAwB,CAAC,wBAA7B,EAAuD;EAGrD,oBAAoB;IAAA,6BAAC,WAAO,KAAP,EAAgB;MACnC,IAAI;QAIF,IAAM,gBAAgB,SAAS,wBAAwB,CAAC,wBAAzB,EAA/B;;QAEA,IAAI,CAAC,gBAAL,EAAuB;UAErB;QACD;;QAED,IAAM,YAAY,GAAuC,IAAI,CAAC,KAAL,CAAW,gBAAX,CAAzD;;QACA,IAAI,YAAJ,YAAI,YAAY,CAAE,SAAlB,EAA6B;UAG3B,MAAM,oBAAoB,CAAC,KAAD,CAA1B;QACD;MACF,CAjBD,CAiBE,OAAO,CAAP,EAAU;QACV,OAAO,CAAC,IAAR,CACE,0GADF,EAEE,CAFF;MAID;IACF,CAxBmB;;IAAA;MAAA;IAAA;EAAA,IAApB;EA6BA,wBAAwB,CAAC,wBAAzB,GAAoD,IAApD,CAAyD,sCAAzD;AACD,CAjCD,MAiCO;EACL,OAAO,CAAC,IAAR,8IAEE,IAAI,mBAAJ,CAAwB,0BAAxB,EAAoD,0BAApD,CAFF;AAID","sourcesContent":["import 'abort-controller/polyfill';\nimport { UnavailabilityError } from 'expo-modules-core';\n\nimport ServerRegistrationModule from './ServerRegistrationModule';\nimport { addPushTokenListener } from './TokenEmitter';\nimport { DevicePushToken } from './Tokens.types';\nimport getDevicePushTokenAsync from './getDevicePushTokenAsync';\nimport { updateDevicePushTokenAsync as updateDevicePushTokenAsyncWithSignal } from './utils/updateDevicePushTokenAsync';\n\nlet lastAbortController: AbortController | null = null;\nasync function updatePushTokenAsync(token: DevicePushToken) {\n  // Abort current update process\n  lastAbortController?.abort();\n  lastAbortController = new AbortController();\n  return await updateDevicePushTokenAsyncWithSignal(lastAbortController.signal, token);\n}\n\n/**\n * Encapsulates device server registration data\n */\nexport type DevicePushTokenRegistration = {\n  isEnabled: boolean;\n};\n\n/**\n * Sets the registration information so that the device push token gets pushed\n * to the given registration endpoint\n * @param registration Registration endpoint to inform of new tokens\n */\nexport async function setAutoServerRegistrationEnabledAsync(enabled: boolean) {\n  // We are overwriting registration, so we shouldn't let\n  // any pending request complete.\n  lastAbortController?.abort();\n\n  if (!ServerRegistrationModule.setRegistrationInfoAsync) {\n    throw new UnavailabilityError('ServerRegistrationModule', 'setRegistrationInfoAsync');\n  }\n\n  await ServerRegistrationModule.setRegistrationInfoAsync(\n    enabled ? JSON.stringify({ isEnabled: enabled }) : null\n  );\n}\n\n/**\n * This function is exported only for testing purposes.\n */\nexport async function __handlePersistedRegistrationInfoAsync(\n  registrationInfo: string | null | undefined\n) {\n  if (!registrationInfo) {\n    // No registration info, nothing to do\n    return;\n  }\n\n  let registration: DevicePushTokenRegistration | null = null;\n  try {\n    registration = JSON.parse(registrationInfo);\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Error encountered while fetching registration information for auto token updates.',\n      e\n    );\n  }\n\n  if (!registration?.isEnabled) {\n    // Registration is invalid or not enabled, nothing more to do\n    return;\n  }\n\n  try {\n    // Since the registration is enabled, fetching a \"new\" device token\n    // shouldn't be a problem.\n    const latestDevicePushToken = await getDevicePushTokenAsync();\n    await updatePushTokenAsync(latestDevicePushToken);\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Error encountered while updating server registration with latest device push token.',\n      e\n    );\n  }\n}\n\nif (ServerRegistrationModule.getRegistrationInfoAsync) {\n  // A global scope (to get all the updates) device push token\n  // subscription, never cleared.\n  addPushTokenListener(async (token) => {\n    try {\n      // Before updating the push token on server we always check if we should\n      // Since modules can't change their method availability while running, we\n      // can assert it's defined.\n      const registrationInfo = await ServerRegistrationModule.getRegistrationInfoAsync!();\n\n      if (!registrationInfo) {\n        // Registration is not enabled\n        return;\n      }\n\n      const registration: DevicePushTokenRegistration | null = JSON.parse(registrationInfo);\n      if (registration?.isEnabled) {\n        // Dispatch an abortable task to update\n        // registration with new token.\n        await updatePushTokenAsync(token);\n      }\n    } catch (e) {\n      console.warn(\n        '[expo-notifications] Error encountered while updating server registration with latest device push token.',\n        e\n      );\n    }\n  });\n\n  // Verify if persisted registration\n  // has successfully uploaded last known\n  // device push token. If not, retry.\n  ServerRegistrationModule.getRegistrationInfoAsync().then(__handlePersistedRegistrationInfoAsync);\n} else {\n  console.warn(\n    `[expo-notifications] Error encountered while fetching auto-registration state, new tokens will not be automatically registered on server.`,\n    new UnavailabilityError('ServerRegistrationModule', 'getRegistrationInfoAsync')\n  );\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}